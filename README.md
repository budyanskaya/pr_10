# Практическая работа 10. Аналитика с использованием сложных типов данных. Поиск и анализ продаж.
## Цель: освоить методы создания полнотекстового поиска в базе данных PostgreSQL с использованием материализованных представлений и индексов GIN. Научиться формировать запросы для поиска клиентов по различным критериям, включая их контактные данные и историю покупок. Развить навыки обработки и анализа данных с помощью SQL, включая использование tsvector, tsquery, plainto_tsquery, а также выполнение перекрестных соединений и агрегаций для оценки поведения клиентов и анализа продаж.

Руководитель отдела продаж выявил проблему: у отдела продаж нет простого способа найти клиента. К счастью, вы вызвались создать проверенную внутреннюю поисковую систему, которая сделает всех клиентов доступными для поиска по их контактной информации и продуктам, которые они приобрели в прошлом
## Ход работы
1. Используя таблицу customer_sales, создайте доступное для поиска представление с одной записью для каждого клиента. Это представление
должно быть отключено от столбца customer_id и доступно для поиска по всей базе данных, что связано с этим клиентом:
имя, адрес электронной почты, телефон, приобретенные продукты. Можно также включить и другие поля.
2. Создайте доступный для поиска индекс, созданного вами ранее
представления.
3. У кулера с водой продавец спрашивает, можете ли вы использовать свой новый поисковый прототип, чтобы найти покупателя по имени Дэнни, купившего скутер Bat. Запросите новое представление с возможностью поиска, используя ключевые слова «Danny Bat». Какое количество строк вы получили?
4. Отдел продаж хочет знать, насколько часто люди покупают скутер и
автомобиль. Выполните перекрестное соединение таблицы продуктов с самой собой, чтобы получить все отдельные пары продуктов и удалить одинаковые пары (например, если название продукта совпадает). Для каждой пары выполните поиск в
представлении, чтобы узнать, сколько клиентов соответствует обоим продуктам в паре. Можно предположить, что выпуски ограниченной серии можно сгруппировать вместе с их аналогом стандартной модели (например, Bat и Bat Limited Edition можно считать одним и тем же скутером).
## Задание 1. Сначала создаем материализованное представление для таблицы customer_sales
````
CREATE MATERIALIZED VIEW customer_search AS (
SELECT
	customer_json -> 'customer_id' AS customer_id, customer_json,
	to_tsvector('english', customer_json) AS search_vector
	FROM customer_sales
);
````
## Задание 2. После выполнения первого запроса создаем индекс GIN в представлении
````
CREATE INDEX customer_search_gin_idx ON customer_search USING GIN(search_vector);
````
## Задание 3. Теперь выполняем запрос, используя новую базу данных с возможностью поиска
````
SELECT
	customer_id,
	customer_json
FROM customer_search
WHERE search_vector @@ plainto_tsquery('english', 'Danny Bat');
````
После выполнения запроса, получаем следующий результат:

![image](https://github.com/user-attachments/assets/0f9f614b-ef0f-47e1-99c8-456fb19b68d8)

## Задание 4. Сейчас мы должны вывести уникальный список скутеров и автомобилей (и удаление ограниченных выпусков) с помощью DISTINCT
````
SELECT DISTINCT
	p1.model,
	p2.model
FROM products p1
	LEFT JOIN products p2 ON TRUE
WHERE p1.product_type = 'scooter'
	AND p2.product_type = 'automobile'
	AND p1.model NOT ILIKE '%Limited
	Edition%';
````
Получаем следующий результат:

![image](https://github.com/user-attachments/assets/5d152c90-d652-4887-a8b8-e001b485f601)

## Задание 5. Проделаем преобразование вывода в запрос
````
SELECT DISTINCT
	plainto_tsquery('english', p1.model) &&
	plainto_tsquery('english', p2.model)
FROM products p1
	LEFT JOIN products p2 ON TRUE
WHERE p1.product_type = 'scooter'
	AND p2.product_type = 'automobile'
	AND p1.model NOT ILIKE '%Limited Edition%';
````
Выполняем запрос и получаем результат:

![image](https://github.com/user-attachments/assets/54b23719-da3f-4fbc-888a-27a4ea12fc6c)

## Задание 6. Напишем запрос базы данных, используя каждый из объектов tsquery, и подсчитать вхождения для каждого объекта
````
SELECT
sub.query,
	(
		SELECT COUNT(1)
		FROM customer_search
		WHERE customer_search.search_vector @@ sub.query)
FROM (
	SELECT DISTINCT
		plainto_tsquery('english', p1.model) &&
		plainto_tsquery('english', p2.model) AS query
	FROM products p1
	LEFT JOIN products p2 ON TRUE
	WHERE p1.product_type = 'scooter'
	AND p2.product_type = 'automobile'
	AND p1.model NOT ILIKE '%Limited Edition%'
	) sub
ORDER BY 2 DESC;
````
Получаем следующий результат:

![image](https://github.com/user-attachments/assets/cb13760a-06c7-4ade-ae75-891d6f90af52)

## Вывод: в ходе работы мы освоили методы создания полнотекстового поиска в базе данных PostgreSQL с использованием материализованных представлений и индексов GIN. Научились формировать запросы для поиска клиентов по различным критериям, включая их контактные данные и историю покупок, а также мы развили навыки обработки и анализа данных с помощью SQL, включая использование tsvector, tsquery, plainto_tsquery
